<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about.html"><strong aria-hidden="true">1.</strong> 关于</a></li><li class="chapter-item expanded "><a href="Rust/index.html"><strong aria-hidden="true">2.</strong> Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Rust/rust_error_handle.html"><strong aria-hidden="true">2.1.</strong> 细说Rust错误处理</a></li><li class="chapter-item expanded "><a href="Rust/crates_private_alternative_registry.html"><strong aria-hidden="true">2.2.</strong> Rust crates私有化部署指南</a></li><li class="chapter-item expanded "><a href="Rust/advice_rust_code_with_block.html"><strong aria-hidden="true">2.3.</strong> Rust代码优化-闭包惰性求值</a></li></ol></li><li class="chapter-item expanded "><a href="Golang/readmd.html"><strong aria-hidden="true">3.</strong> Golang</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#介绍" id="介绍">介绍</a></h1>
<h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<h1><a class="header" href="#细说rust错误处理" id="细说rust错误处理">细说Rust错误处理</a></h1>
<ul>
<li><a href="Rust/rust_error_handle.html#%E7%BB%86%E8%AF%B4rust%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">细说Rust错误处理</a>
<ul>
<li><a href="Rust/rust_error_handle.html#1-%E5%89%8D%E8%A8%80">1. 前言</a></li>
<li><a href="Rust/rust_error_handle.html#2-%E8%83%8C%E6%99%AF">2. 背景</a></li>
<li><a href="Rust/rust_error_handle.html#3-unwrap%E7%9A%84%E5%8D%B1%E5%AE%B3">3. unwrap的危害!</a></li>
<li><a href="Rust/rust_error_handle.html#4-%E5%AF%B9%E6%AF%94%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">4. 对比语言处理错误</a>
<ul>
<li><a href="Rust/rust_error_handle.html#41-golang%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%BC%94%E7%A4%BA">4.1 golang的错误处理演示</a></li>
<li><a href="Rust/rust_error_handle.html#42-rust-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E7%A4%BA%E4%BE%8B">4.2 Rust 错误处理示例</a></li>
</ul>
</li>
<li><a href="Rust/rust_error_handle.html#5-rust%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86">5. Rust中的错误处理</a></li>
<li><a href="Rust/rust_error_handle.html#6-%E8%87%AA%E5%AE%9A%E4%B9%89error%E8%BD%AC%E6%8D%A2from">6. 自定义Error转换:From</a></li>
<li><a href="Rust/rust_error_handle.html#7-%E9%87%8D%E5%91%BD%E5%90%8Dresult">7. 重命名Result</a></li>
<li><a href="Rust/rust_error_handle.html#8-option%E8%BD%AC%E6%8D%A2">8. Option转换</a></li>
<li><a href="Rust/rust_error_handle.html#9-%E9%81%BF%E5%85%8Dunwrap">9. 避免unwrap()</a></li>
<li><a href="Rust/rust_error_handle.html#10-%E8%87%AA%E5%AE%9A%E4%B9%89error%E5%90%8C%E7%BA%A7%E8%BD%AC%E6%8D%A2">10. 自定义Error同级转换</a></li>
<li><a href="Rust/rust_error_handle.html#11-error%E5%B8%B8%E8%A7%81%E5%BC%80%E6%BA%90%E5%BA%93">11. Error常见开源库</a></li>
<li><a href="Rust/rust_error_handle.html#12-%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">12. 参考链接</a></li>
<li><a href="Rust/rust_error_handle.html#13-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%AE%9E%E6%88%98">13 错误处理实战</a></li>
<li><a href="Rust/rust_error_handle.html#14-%E6%80%BB%E7%BB%93">14. 总结</a></li>
</ul>
</li>
</ul>
<p><img src="https://github.com/baoyachi/rust-error-handle/raw/master/handle_error.png" alt="handle-error.png" /></p>
<p>原文地址:<a href="https://github.com/baoyachi/rust-error-handle">https://github.com/baoyachi/rust-error-handle</a></p>
<h2><a class="header" href="#1-前言" id="1-前言">1. 前言</a></h2>
<p>这篇文章写得比较长，全文读完大约需要15-20min，如果对<code>Rust</code>的错误处理不清楚或还有些许模糊的同学，请静下心来细细阅读。当读完该篇文章后，可以说对<code>Rust</code>的错误处理可以做到掌握自如。</p>
<p>笔者花费较长篇幅来描述<strong>错误处理</strong>的来去，详细介绍其及一步步梳理内容，望大家能耐心读完后对大家有所帮助。当然，在写这篇文章之时，也借阅了大量互联网资料，详见链接见底部<strong>参考链接</strong></p>
<p>掌握好<code>Rust</code>的错误设计，不仅可以提升我们对错误处理的认识，对代码结构、层次都有很大的帮助。那废话不多说，那我们开启这段阅读之旅吧😄！</p>
<h2><a class="header" href="#2-背景" id="2-背景">2. 背景</a></h2>
<p>笔者在写这篇文章时，也翻阅一些资料关于<code>Rust</code>的错误处理资料，多数是对其一笔带过，导致之前接触过其他语言的新同学来说，上手处理<code>Rust</code>的错误会有<strong>当头棒喝</strong>的感觉。找些资料发现<strong>unwrap()<strong>也可以解决问题，然后心中暗自窃喜，程序在运行过程中，<strong>因为忽略检查或程序逻辑判断</strong>，导致某些情况，程序</strong>panic</strong>。这可能是我们最不愿看到的现象，遂又回到起点，重新去了解<code>Rust</code>的错误处理。</p>
<p>这篇文章，通过一步步介绍，让大家清晰知道<code>Rust</code>的错误处理的究竟。介绍在<code>Rust</code>中的错误使用及如何处理错误，以及在实际工作中关于其使用技巧。</p>
<h2><a class="header" href="#3-unwrap的危害" id="3-unwrap的危害">3. unwrap的危害!</a></h2>
<p>下面我们来看一段代码,执行一下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let path = &quot;/tmp/dat&quot;;
    println!(&quot;{}&quot;, read_file(path));
}

fn read_file(path: &amp;str) -&gt; String {
    std::fs::read_to_string(path).unwrap()
}
</code></pre></pre>
<p>程序执行结果：</p>
<pre><code class="language-bash">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/libcore/result.rs:1188:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
  ...
  15: rust_sugar::read_file
             at src/main.rs:7
  16: rust_sugar::main
             at src/main.rs:3
  ...
  25: rust_sugar::read_file
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
<p>什么，因为<code>path</code>路径不对，程序竟然崩溃了，这个是我们不能接受的！</p>
<p><strong>unwrap()</strong> 这个操作在rust代码中，应该看过很多这种代码，甚至此时我们正在使用它。它主要用于<code>Option</code>或<code>Result</code>的打开其包装的结果。常常我们在代码中，使用简单，或快速处理，使用了 <strong>unwrap()</strong> 的操作，但是，它是一个非常危险的信号!</p>
<p>可能因为<strong>没有程序检查或校验</strong>，潜在的bug可能就出现其中，使得我们程序往往就<strong>panic</strong>了。这可能使我们最不愿看到的现象。</p>
<p>在实际项目开发中，程序中可能充斥着大量代码，我们很难避免<strong>unwrap()<strong>的出现，为了解决这种问题，我们通过做</strong>code review</strong>,或使用脚本工具检查其降低其出现的可能性。</p>
<p>通常每个项目都有一些约束，或许：在大型项目开发中， 不用<strong>unwrap()</strong> 方法，使用其他方式处理程序，<strong>unwrap()</strong> 的不出现可能会使得程序的健壮性高出很多。</p>
<p>这里前提是团队或大型项目，如果只是写一个简单例子（demo）就不在本篇文章的讨论范畴。因为一个Demo的问题，可能只是快速<strong>示范或演示</strong>，不考虑程序健壮性, <strong>unwrap()</strong> 的操作可能会更方便代码表达。</p>
<p>可能有人会问，我们通常跑程序<strong>unit test</strong>，其中的很多<strong>mock</strong>数据会有 <strong>unwrap()</strong> 的操作，我们只是为了在单元测试中使得程序简单。这种也能不使用吗？答案：是的，完全可以不使用 <strong>unwrap()</strong> 也可以做到的。</p>
<h2><a class="header" href="#4-对比语言处理错误" id="4-对比语言处理错误">4. 对比语言处理错误</a></h2>
<p>说到<strong>unwrap()</strong>，我们不得不提到<code>rust</code>的错误处理，<strong>unwrap()</strong> 和<code>Rust</code>的错误处理是密不可分的。</p>
<h3><a class="header" href="#41-golang的错误处理演示" id="41-golang的错误处理演示">4.1 golang的错误处理演示</a></h3>
<p>如果了解<code>golang</code>的话，应该清楚下面这段代码的意思：</p>
<pre><code class="language-go">package main

import (
    &quot;io/ioutil&quot;
    &quot;log&quot;
)

func main() {
    path := &quot;/tmp/dat&quot;  //文件路径
    file, err := readFile(path) 
    if err != nil {
        log.Fatal(err) //错误打印
    }
    println(&quot;%s&quot;, file) //打印文件内容
}

func readFile(path string) (string, error) {
    dat, err := ioutil.ReadFile(path)  //读取文件内容
    if err != nil {  //判断err是否为nil
        return &quot;&quot;, err  //不为nil,返回err结果
    }
    return string(dat), nil  //err=nil,返回读取文件内容
}
</code></pre>
<p>我们执行下程序，打印如下。执行错误，当然，因为我们给的文件路径不存在，程序报错。</p>
<pre><code class="language-bash">2020/02/24 01:24:04 open /tmp/dat: no such file or directory
</code></pre>
<p>这里，<code>golang</code>采用多返回值方式，程序报错返回错误问题，通过判断 <strong>err!=nil</strong> 来决定程序是否继续执行或终止该逻辑。当然，如果接触过<code>golang</code>项目时，会发现程序中大量充斥着<code>if err!=nil</code>的代码，对此网上有对<code>if err!=nil</code>进行了很多讨论，因为这个不在本篇文章的范畴中，在此不对其追溯、讨论。</p>
<h3><a class="header" href="#42-rust-错误处理示例" id="42-rust-错误处理示例">4.2 Rust 错误处理示例</a></h3>
<p>对比了<code>golang</code>代码，我们对照上面的例子，看下在<code>Rust</code>中如何编写这段程序，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let path = &quot;/tmp/dat&quot;;  //文件路径
    match read_file(path) { //判断方法结果
        Ok(file) =&gt; { println!(&quot;{}&quot;, file) } //OK 代表读取到文件内容，正确打印文件内容
        Err(e) =&gt; { println!(&quot;{} {}&quot;, path, e) } //Err代表结果不存在，打印错误结果
    }
}

fn read_file(path: &amp;str) -&gt; Result&lt;String,std::io::Error&gt; { //Result作为结果返回值
    std::fs::read_to_string(path) //读取文件内容
}
</code></pre></pre>
<p>当前，因为我们给的文件路径不存在，程序报错，打印内容如下：</p>
<pre><code class="language-bash">No such file or directory (os error 2)
</code></pre>
<p>在<code>Rust</code>代表中，<code>Result</code>是一个<code>enum</code>枚举对象,部分源码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Result&lt;T, E&gt; {
    /// Contains the success value
    Ok(#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)] T),

    /// Contains the error value
    Err(#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)] E),
}
<span class="boring">}
</span></code></pre></pre>
<p>通常我们使用<code>Result</code>的枚举对象作为程序的返回值，通过<code>Result</code>来判断其结果，我们使用<code>match</code>匹配的方式来获取<code>Result</code>的内容，判断正常（Ok）或错误(Err)。</p>
<p>或许，我们大致向上看去，<code>golang</code>代码和<code>Rust</code>代码没有本质区别，都是采用返回值方式，给出程序结果。下面我们就对比两种语言说说之间区别：</p>
<ul>
<li><code>golang</code>采用多返回值方式，我们在拿到目标结果时（上面是指文件内容<em>file</em>），需要首先对<code>err</code>判断是否为<code>nil</code>,并且我们在<code>return</code>时，需要给<strong>多返回值</strong>分别赋值，调用时需要对 <code>if err!=nil</code> 做结果判断。</li>
<li><code>Rust</code>中采用<code>Result</code>的枚举对象做结果返回。枚举的好处是：多选一。因为<code>Result</code>的枚举类型为<code>Ok</code>和<code>Err</code>，使得我们每次在返回<code>Result</code>的结果时，要么是<code>Ok</code>,要么是<code>Err</code>。它不需要<code>return</code>结果同时给两个值赋值，这样的情况只会存在一种可能性: <strong>Ok or Err</strong> 。</li>
<li>golang的函数调用需要对 <code>if err!=nil</code>做结果判断，因为这段代码 判断是<strong>手动逻辑</strong>，往往我们可能因为疏忽，导致这段逻辑缺失，缺少校验。当然，我们在编写代码期间可以通过某些工具 <code>lint</code> 扫描出这种潜在bug。</li>
<li><code>Rust</code>的<code>match</code>判断是自动打开，当然你也可以选择忽略其中某一个枚举值,我们不在此说明。</li>
</ul>
<p>可能有人发现，如果我有多个函数，需要多个函数的执行结果，这样需要<code>match</code>代码多次，代码会不会是一坨一坨，显得代码很臃肿，难看。是的，这个问题提出的的确是有这种问题，不过这个在后面我们讲解的时候，会通过程序语法糖避免多次<code>match</code>多次结果的问题，不过我们在此先不叙说，后面将有介绍。</p>
<h2><a class="header" href="#5-rust中的错误处理" id="5-rust中的错误处理">5. Rust中的错误处理</a></h2>
<p>前面不管是<code>golang</code>还是<code>Rust</code>采用<code>return</code>返回值方式，两者都是为了解决程序中错误处理的问题。好了，前面说了这么多，我们还是回归正题：Rust中是如何对错误进行处理的？</p>
<p>要想细致了解<code>Rust</code>的错误处理，我们需要了解<code>std::error::Error</code>，该trait的内部方法，部分代码如下：
参考链接：<a href="https://doc.rust-lang.org/std/error/trait.Error.html">https://doc.rust-lang.org/std/error/trait.Error.html</a></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Error: Debug + Display {

    fn description(&amp;self) -&gt; &amp;str {
        &quot;description() is deprecated; use Display&quot;
    }

    #[rustc_deprecated(since = &quot;1.33.0&quot;, reason = &quot;replaced by Error::source, which can support \
                                                   downcasting&quot;)]

    fn cause(&amp;self) -&gt; Option&lt;&amp;dyn Error&gt; {
        self.source()
    }

    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn Error + 'static)&gt; { None }

    #[doc(hidden)]
    fn type_id(&amp;self, _: private::Internal) -&gt; TypeId where Self: 'static {
        TypeId::of::&lt;Self&gt;()
    }

    #[unstable(feature = &quot;backtrace&quot;, issue = &quot;53487&quot;)]
    fn backtrace(&amp;self) -&gt; Option&lt;&amp;Backtrace&gt; {
        None
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><code>description()</code>在文档介绍中，尽管使用它不会导致编译警告，但新代码应该实现<code>impl Display</code> ，新<code>impl</code>的可以省略，不用实现该方法, 要获取字符串形式的错误描述，请使用<code>to_string()</code>。</p>
</li>
<li>
<p><code>cause()</code>在<strong>1.33.0</strong>被抛弃，取而代之使用<code>source()</code>方法，新<code>impl</code>的不用实现该方法。</p>
</li>
<li>
<p><code>source()</code>此错误的低级源，如果内部有错误类型<code>Err</code>返回：<code>Some(e)</code>,如果没有返回：<code>None</code>。</p>
<ul>
<li>如果当前<code>Error</code>是低级别的<code>Error</code>,并没有<strong>子Error</strong>,需要返回<code>None</code>。介于其本身默认有返回值<code>None</code>，可以<strong>不覆盖</strong>该方法。</li>
<li>如果当前<code>Error</code>包含<strong>子Error</strong>,需要返回<strong>子Error</strong>：<code>Some(err)</code>,需要<strong>覆盖</strong>该方法。</li>
</ul>
</li>
<li>
<p><code>type_id()</code>该方法被隐藏。</p>
</li>
<li>
<p><code>backtrace()</code>返回发生此错误的堆栈追溯，因为标记<code>unstable</code>，在<code>Rust</code>的<code>stable</code>版本不被使用。</p>
</li>
<li>
<p>自定义的<code>Error</code>需要<strong>impl std::fmt::Debug</strong>的trait,当然我们只需要在默认对象上添加注解：<code>#[derive(Debug)]</code>即可。</p>
</li>
</ul>
<p>总结一下，自定义一个<code>error</code>需要实现如下几步：</p>
<ul>
<li>手动实现impl <code>std::fmt::Display</code>的trait,并<strong>实现</strong> <code>fmt(...)</code>方法。</li>
<li>手动实现impl <code>std::fmt::Debug</code>的<code>trait</code>，一般直接添加注解即可：<code>#[derive(Debug)]</code></li>
<li>手动实现impl <code>std::error::Error</code>的<code>trait</code>,并根据自身<code>error</code>级别是否<strong>覆盖</strong><code>std::error::Error</code>中的<code>source()</code>方法。</li>
</ul>
<p>下面我们自己手动实现下<code>Rust</code>的<strong>自定义错误:CustomError</strong></p>
<pre><pre class="playground"><code class="language-rust">use std::error::Error;

///自定义类型 Error,实现std::fmt::Debug的trait
#[derive(Debug)]
struct CustomError {
    err: ChildError,
}

///实现Display的trait，并实现fmt方法
impl std::fmt::Display for CustomError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;CustomError is here!&quot;)
    }
}

///实现Error的trait,因为有子Error:ChildError,需要覆盖source()方法,返回Some(err)
impl std::error::Error for CustomError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        Some(&amp;self.err)
    }
}


///子类型 Error,实现std::fmt::Debug的trait
#[derive(Debug)]
struct ChildError;

///实现Display的trait，并实现fmt方法
impl std::fmt::Display for ChildError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;ChildError is here!&quot;)
    }
}

///实现Error的trait,因为没有子Error,不需要覆盖source()方法
impl std::error::Error for ChildError {}

///构建一个Result的结果，返回自定义的error:CustomError
fn get_super_error() -&gt; Result&lt;(), CustomError&gt; {
    Err(CustomError { err: ChildError })
}

fn main() {
    match get_super_error() {
        Err(e) =&gt; {
            println!(&quot;Error: {}&quot;, e);
            println!(&quot;Caused by: {}&quot;, e.source().unwrap());
        }
        _ =&gt; println!(&quot;No error&quot;),
    }
}
</code></pre></pre>
<ul>
<li><code>ChildError</code>为子类型<code>Error</code>,<strong>没有覆盖</strong><code>source()</code>方法，空实现了<code>std::error::Error</code></li>
<li><code>CustomError</code>有子类型<code>ChildError</code>,<strong>覆盖</strong>了<code>source()</code>,并返回了子类型Option值：<code>Some(&amp;self.err)</code></li>
</ul>
<p>运行执行结果，显示如下：</p>
<pre><code class="language-bash">Error: CustomError is here!
Caused by: ChildError is here!
</code></pre>
<p>至此，我们就了解了如何实现<code>Rust</code>中<strong>自定义Error</strong>了。</p>
<h2><a class="header" href="#6-自定义error转换from" id="6-自定义error转换from">6. 自定义Error转换:From</a></h2>
<p>上面我们说到，函数返回<code>Result</code>的结果时，需要获取函数的返回值是成功(Ok)还是失败(Err)，需要使用<code>match</code>匹配，我们看下多函数之间调用是如何解决这类问题的？假设我们有个场景：</p>
<ul>
<li>读取一文件</li>
<li>将文件内容转化为<code>UTF8</code>格式</li>
<li>将转换后格式内容转为<code>u32</code>的数字。</li>
</ul>
<p>所以我们有了下面三个函数(省略部分代码)：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

///读取文件内容
fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}
<span class="boring">}
</span></code></pre></pre>
<p>最终，我们得到<code>u32</code>的数字，对于该场景如何组织我们代码呢？</p>
<ul>
<li><code>unwrap()</code>直接打开三个方法，取出值。这种方式太暴力，并且会有<code>bug</code>,造成程序<code>panic</code>,不被采纳。</li>
<li><code>match</code>匹配，如何返回OK,继续下一步，否则报错终止逻辑，那我们试试。</li>
</ul>
<p>参考代码如下:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let path = &quot;./dat&quot;;
    match read_file(path) {
        Ok(v) =&gt; {
            match to_utf8(v.as_bytes()) {
                Ok(u) =&gt; {
                    match to_u32(u) {
                        Ok(t) =&gt; {
                            println!(&quot;num:{:?}&quot;, u);
                        }
                        Err(e) =&gt; {
                            println!(&quot;{} {}&quot;, path, e)
                        }
                    }
                }
                Err(e) =&gt; {
                    println!(&quot;{} {}&quot;, path, e)
                }
            }
        }
        Err(e) =&gt; {
            println!(&quot;{} {}&quot;, path, e)
        }
    }
}

///读取文件内容
fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}
</code></pre></pre>
<p>天啊，虽然是实现了上面场景的需求，但是代码犹如叠罗汉，程序结构越来越深啊，这个是我们没法接受的！<code>match</code>匹配导致程序如此<strong>不堪一击</strong>。那么有没有第三种方法呢？当然是有的：<code>From</code>转换。</p>
<p>前面我们说到如何<strong>自定义的Error</strong>,如何我们将上面三个<code>error</code>收纳到我们<strong>自定义的Error</strong>中，将它们三个<code>Error</code>变成<strong>自定义Error</strong>的<strong>子Error</strong>，这样我们对外的<code>Result</code>统一返回<strong>自定义的Error</strong>。这样程序应该可以改变点什么，我们来试试吧。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>CustomError</code>为我们实现的<strong>自定义Error</strong></li>
<li><code>CustomError</code>有三个<strong>子类型Error</strong></li>
<li><code>CustomError</code>分别实现了三个<strong>子类型Error</strong> <code>From</code>的trait,将其类型包装为<strong>自定义Error</strong>的子类型</li>
</ul>
<p>好了，有了自定义的<code>CustomError</code>，那怎么使用呢? 我们看代码：</p>
<pre><pre class="playground"><code class="language-rust">use std::io::Error as IoError;
use std::str::Utf8Error;
use std::num::ParseIntError;
use std::fmt::{Display, Formatter};


fn main() -&gt; std::result::Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}

///读取文件内容
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, std::str::Utf8Error&gt; {
    std::str::from_utf8(v)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, std::num::ParseIntError&gt; {
    v.parse::&lt;u32&gt;()
}


#[derive(Debug)]
enum CustomError {
    ParseIntError(std::num::ParseIntError),
    Utf8Error(std::str::Utf8Error),
    IoError(std::io::Error),
}
impl std::error::Error for CustomError{
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn std::error::Error + 'static)&gt; {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; Some(e),
            CustomError::Utf8Error(ref e) =&gt; Some(e),
            CustomError::ParseIntError(ref e) =&gt; Some(e),
        }
    }
}

impl Display for CustomError{
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            CustomError::IoError(ref e) =&gt; e.fmt(f),
            CustomError::Utf8Error(ref e) =&gt; e.fmt(f),
            CustomError::ParseIntError(ref e) =&gt; e.fmt(f),
        }
    }
}

impl From&lt;ParseIntError&gt; for CustomError {
    fn from(s: std::num::ParseIntError) -&gt; Self {
        CustomError::ParseIntError(s)
    }
}

impl From&lt;IoError&gt; for CustomError {
    fn from(s: std::io::Error) -&gt; Self {
        CustomError::IoError(s)
    }
}

impl From&lt;Utf8Error&gt; for CustomError {
    fn from(s: std::str::Utf8Error) -&gt; Self {
        CustomError::Utf8Error(s)
    }
}
</code></pre></pre>
<p>其实我们主要关心的是这段代码：</p>
<pre><pre class="playground"><code class="language-rust">fn main() -&gt; Result&lt;(),CustomError&gt;{
    let path = &quot;./dat&quot;;
    let v = read_file(path)?;
    let x = to_utf8(v.as_bytes())?;
    let u = to_u32(x)?;
    println!(&quot;num:{:?}&quot;,u);
    Ok(())
}
</code></pre></pre>
<p>我们使用了<code>?</code>来替代原来的<code>match</code>匹配的方式。<code>?</code>使用问号作用在函数的结束，意思是：</p>
<ul>
<li>程序接受了一个<code>Result&lt;(),CustomError&gt;</code>自定义的错误类型。</li>
<li>当前如果函数结果错误，程序自动抛出<code>Err</code>自身错误类型，并包含相关自己类型错误信息，因为我们做了<code>From</code>转换的操作，该函数的自身类型错误会通过实现的<code>From</code>操作自动转化为<code>CustomError</code>的自定义类型错误。</li>
<li>当前如果函数结果正确，继续之后逻辑，直到程序结束。</li>
</ul>
<p>这样，我们通过<code>From</code>和<code>?</code>解决了之前<code>match</code>匹配代码层级深的问题，因为这种转换是<strong>无感知</strong>的，使得我们在处理好错误类型后，只需要关心我们的目标值即可，这样不需要显示对<code>Err(e)</code>的数据单独处理，使得我们在函数后添加<code>?</code>后，程序一切都是自动了。</p>
<p>还记得我们之前讨论在对比<code>golang</code>的错误处理时的:<code>if err!=nil</code>的逻辑了吗，这种因为用了<code>?</code>语法糖使得该段判断将不再存在。</p>
<p>另外，我们还注意到，<code>Result</code>的结果可以作用在<code>main</code>函数上，</p>
<ul>
<li>是的，<code>Result</code>的结果不仅能作用在<code>main</code>函数上</li>
<li><code>Result</code>还可以作用在单元测试上，这就是我们文中刚开始提到的：因为有了<code>Result</code>的作用，使得我们在程序中几乎可以完全摒弃<code>unwrap()</code>的代码块，使得程序更轻，大大减少潜在问题，程序组织结构更加清晰。</li>
</ul>
<p>下面这是作用在单元测试上的<code>Result</code>的代码：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_num() -&gt; std::result::Result&lt;(), CustomError&gt; {
        let path = &quot;./dat&quot;;
        let v = read_file(path)?;
        let x = to_utf8(v.as_bytes())?;
        let u = to_u32(x)?;
        assert_eq!(u, 8);
        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#7-重命名result" id="7-重命名result">7. 重命名Result</a></h2>
<p>我们在实际项目中，会大量使用如上的<code>Result</code>结果，并且<code>Result</code>的<code>Err</code>类型是我们<code>自定义错误</code>,导致我们写程序时会显得非常<strong>啰嗦</strong>、<strong>冗余</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///读取文件内容
fn read_file(path: &amp;str) -&gt; std::result::Result&lt;String, CustomError&gt; {
    let val = std::fs::read_to_string(path)?;
    Ok(val)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; std::result::Result&lt;&amp;str, CustomError&gt; {
    let x = std::str::from_utf8(v)?;
    Ok(x)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; std::result::Result&lt;u32, CustomError&gt; {
    let i = v.parse::&lt;u32&gt;()?;
    Ok(i)
}
<span class="boring">}
</span></code></pre></pre>
<p>我们的程序中，会大量充斥着这种<strong>模板代码</strong>，<code>Rust</code>本身支持对类型自定义，使得我们只需要重命名<code>Result</code>即可:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type IResult&lt;I&gt; = std::result::Result&lt;I, CustomError&gt;; ///自定义Result类型：IResult
<span class="boring">}
</span></code></pre></pre>
<p>这样，凡是使用的是自定义类型错误的<code>Result</code>都可以使用<code>IResult</code>来替换<code>std::result::Result</code>的类型，使得简化程序，隐藏<code>Error</code>类型及细节，关注目标主体，代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>///读取文件内容
fn read_file(path: &amp;str) -&gt; IResult&lt;String&gt; {
    let val = std::fs::read_to_string(path)?;
    Ok(val)
}

/// 转换为utf8内容
fn to_utf8(v: &amp;[u8]) -&gt; IResult&lt;&amp;str&gt; {
    let x = std::str::from_utf8(v)?;
    Ok(x)
}

/// 转化为u32数字
fn to_u32(v: &amp;str) -&gt; IResult&lt;u32&gt; {
    let i = v.parse::&lt;u32&gt;()?;
    Ok(i)
}
<span class="boring">}
</span></code></pre></pre>
<p>将<code>std::result::Result&lt;I, CustomError&gt;</code> 替换为：<code>IResult&lt;I&gt;</code>类型</p>
<p>当然，会有人提问，如果是多参数类型怎么处理呢，同样，我们只需将<code>OK</code>类型变成 <strong>tuple</strong> <code>(I,O)</code>类型的多参数数据即可，大概这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub type IResult&lt;I, O&gt; = std::result::Result&lt;(I, O), CustomError&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>使用也及其简单，只需要返回：<strong>I</strong>,<strong>O</strong>的具体类型,举个示例：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; IResult&lt;String, u32&gt; {
    Ok((String::from(&quot;bar&quot;), 32))
}
<span class="boring">}
</span></code></pre></pre>
<p>使用重命名类型的<code>Result</code>，使得我们错误类型统一，方便处理。在实际项目中，可以大量看到这种例子的存在。</p>
<h2><a class="header" href="#8-option转换" id="8-option转换">8. Option转换</a></h2>
<p>我们知道，在<code>Rust</code>中，需要使用到<code>unwrap()</code>的方法的对象有<code>Result</code>,<code>Option</code>对象。我们看下<code>Option</code>的大致结构：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Option&lt;T&gt; {
    /// No value
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    None,
    /// Some value `T`
    #[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)]
    Some(#[stable(feature = &quot;rust1&quot;, since = &quot;1.0.0&quot;)] T),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Option</code>本身是一个<code>enum</code>对象，如果该函数（方法）调用结果值没有值，返回<code>None</code>,反之有值返回<code>Some(T)</code></p>
<p>如果我们想获取<code>Some(T)</code>中的<code>T</code>,最直接的方式是：<code>unwrap()</code>。我们前面说过，使用<code>unwrap()</code>的方式太过于暴力，如果出错，程序直接<code>panic</code>，这是我们最不愿意看到的结果。</p>
<p>Ok,那么我们试想下, 利用<code>Option</code>能使用<code>?</code>语法糖吗？如果能用<code>?</code>转换的话，是不是代码结构就更简单了呢？我们尝试下,代码如下：</p>
<pre><pre class="playground"><code class="language-rust">
#[derive(Debug)]
enum Error {
    OptionError(String),
}

impl std::error::Error for Error {}

impl std::fmt::Display for Error {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match &amp;self {
            Error::OptionError(ref e) =&gt; e.fmt(f),
        }
    }
}

pub type Result&lt;I&gt; = std::result::Result&lt;I, Error&gt;;


fn main() -&gt; Result&lt;()&gt; {
    let bar = foo(60)?;
    assert_eq!(&quot;bar&quot;, bar);
    Ok(())
}

fn foo(index: i32) -&gt; Option&lt;String&gt; {
    if index &gt; 60 {
        return Some(&quot;bar&quot;.to_string());
    }
    None
}
</code></pre></pre>
<p>执行结果报错：</p>
<pre><code class="language-bash">error[E0277]: `?` couldn't convert the error to `Error`
  --&gt; src/main.rs:22:22
   |
22 |     let bar = foo(60)?;
   |                      ^ the trait `std::convert::From&lt;std::option::NoneError&gt;` is not implemented for `Error`
   |
   = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `From` trait
   = note: required by `std::convert::From::from`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `hyper-define`.
</code></pre>
<p>提示告诉我们没有转换<code>std::convert::From&lt;std::option::NoneError&gt;</code>，但是<code>NoneError</code>本身是<code>unstable</code>，这样我们没法通过<code>From</code>转换为<strong>自定义Error</strong>。</p>
<p>本身，在<code>Rust</code>的设计中，关于<code>Option</code>和<code>Result</code>就是一对孪生兄弟一样的存在，<code>Option</code>的存在可以忽略异常的细节，直接关注目标主体。当然，<code>Option</code>也可以通过内置的组合器<code>ok_or()</code>方法将其变成<code>Result</code>。我们大致看下实现细节：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Option&lt;T&gt; {
    pub fn ok_or&lt;E&gt;(self, err: E) -&gt; Result&lt;T, E&gt; {
        match self {
            Some(v) =&gt; Ok(v),
            None =&gt; Err(err),
        }
    }
}    
<span class="boring">}
</span></code></pre></pre>
<p>这里通过<code>ok_or()</code>方法通过接收一个<strong>自定义Error</strong>类型，将一个<code>Option</code>-&gt;<code>Result</code>。好的，变成<code>Result</code>的类型，我们就是我们熟悉的领域了，这样处理起来就很灵活。</p>
<p>关于<code>Option</code>的其他处理方式，不在此展开解决，详细的可看下面链接：</p>
<p>延伸链接：<a href="https://stackoverflow.com/questions/59568278/why-does-the-operator-report-the-error-the-trait-bound-noneerror-error-is-no">https://stackoverflow.com/questions/59568278/why-does-the-operator-report-the-error-the-trait-bound-noneerror-error-is-no</a></p>
<h2><a class="header" href="#9-避免unwrap" id="9-避免unwrap">9. 避免unwrap()</a></h2>
<p>有人肯定会有疑问，如果需要判断的逻辑，又不用<code>?</code>这种操作，怎么取出<code>Option</code>或<code>Result</code>的数据呢，当然点子总比办法多，我们来看下<code>Option</code>如何做的：</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if let Some(v) = opt_val(60) {
        println!(&quot;{}&quot;, v);
    }
}

fn opt_val(num: i32) -&gt; Option&lt;String&gt; {
    if num &gt;= 60 {
        return Some(&quot;foo bar&quot;.to_string());
    }
    None
}
</code></pre></pre>
<p>是的，我们使用<code>if let Some(v)</code>的方式取出值，当前<code>else</code>的逻辑就可能需要自己处理了。当然，<code>Option</code>可以这样做，<code>Result</code>也一定可以:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    if let Ok(v) = read_file(&quot;./dat&quot;) {
        println!(&quot;{}&quot;, v);
    }
}

fn read_file(path: &amp;str) -&gt; Result&lt;String, std::io::Error&gt; {
    std::fs::read_to_string(path)
}
</code></pre></pre>
<p>只不过，在处理<code>Result</code>的判断时，使用的是<code>if let Ok(v)</code>，这个和<code>Option</code>的<code>if let Some(v)</code>有所不同。</p>
<p>到这里，<code>unwrap()</code>的代码片在项目中应该可以规避了。补充下，这里强调了几次规避，就如前所言：<strong>团队风格统一，方便管理代码，消除潜在危机</strong>。</p>
<h2><a class="header" href="#10-自定义error同级转换" id="10-自定义error同级转换">10. 自定义Error同级转换</a></h2>
<p>我们在项目中，一个函数（方法）内部会有多次<code>Result</code>的结果判断：<code>?</code>,假设我们自定义的全局Error名称为：<code>GlobalError</code>。</p>
<p>这时候，如果全局有一个<code>Error</code>可能就会出现如下错误：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>std::convert::From&lt;error::GlobalError&lt;A&gt;&gt;` is not implemented for `error::GlobalError&lt;B&gt;
<span class="boring">}
</span></code></pre></pre>
<p>意思是：我们自定义的<code>GlobalError</code>没有通过From&lt;GlobalError<T>&gt;转换我们自己自定义的<code>GlobalError</code>，那这样，就等于<strong>自己转换自己</strong>。注意：</p>
<ul>
<li>第一：这是我们不期望这样做的。</li>
<li>第二：遇到这种自己转换自己的<code>T</code>类型很多，我们不可能把出现的<code>T</code>类型通通实现一遍。
这时候，我们考虑自定义另一个Error了，假设我们视为：<code>InnnerError</code>,我们全局的Error取名为：<code>GlobalError</code>，我们在遇到上面错误时，返回<code>Result&lt;T,InnerError&gt;</code>,这样我们遇到<code>Result&lt;T,GlobalError&gt;</code>时，只需要通过<code>From&lt;T&gt;</code>转换即可，代码示例如下：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl From&lt;InnerError&gt; for GlobalError {
    fn from(s: InnerError) -&gt; Self {
        Error::new(ErrorKind::InnerError(e))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>上面说的这种情况，可能会在项目中出现<strong>多个自定义Error</strong>,出现这种情况时，存在多个不同Error的<code>std::result::Result&lt;T,Err&gt;</code>的返回。这里的<code>Err</code>就可以根据我们业务现状分别反回不同类型了。最终，只要实现了<code>From&lt;T&gt;</code>的<code>trait</code>可转化为最终期望结果。</p>
<h2><a class="header" href="#11-error常见开源库" id="11-error常见开源库">11. Error常见开源库</a></h2>
<p>好了，介绍到这里，我们应该有了非常清晰的认知：关于如何处理<code>Rust</code>的错误处理问题了。但是想想上面的这些逻辑多数是模板代码，我们在实际中，大可不必这样。说到这里，开源社区也有了很多对错误处理库的支持，下面列举了一些：</p>
<ul>
<li><a href="https://github.com/rust-lang-nursery/failure">https://github.com/rust-lang-nursery/failure</a></li>
<li><a href="https://github.com/rust-lang-nursery/error-chain">https://github.com/rust-lang-nursery/error-chain</a></li>
<li><a href="https://github.com/dtolnay/anyhow">https://github.com/dtolnay/anyhow</a></li>
<li><a href="https://github.com/dtolnay/thiserror">https://github.com/dtolnay/thiserror</a></li>
<li><a href="https://github.com/tailhook/quick-error">https://github.com/tailhook/quick-error</a></li>
</ul>
<h2><a class="header" href="#12-参考链接" id="12-参考链接">12. 参考链接</a></h2>
<ul>
<li><a href="https://blog.burntsushi.net/rust-error-handling/">https://blog.burntsushi.net/rust-error-handling/</a></li>
<li><a href="https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html">https://doc.rust-lang.org/edition-guide/rust-2018/error-handling-and-panics/question-mark-in-main-and-tests.html</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error/result.html">https://doc.rust-lang.org/rust-by-example/error/result.html</a></li>
<li><a href="https://doc.rust-lang.org/rust-by-example/error.html">https://doc.rust-lang.org/rust-by-example/error.html</a></li>
<li><a href="https://github.com/rust-lang/rust/issues/43301">https://github.com/rust-lang/rust/issues/43301</a></li>
</ul>
<h2><a class="header" href="#13-错误处理实战" id="13-错误处理实战">13 错误处理实战</a></h2>
<p>这个例子介绍了如何在<code>https://github.com/Geal/nom</code>中处理错误，这里就不展开介绍了，有兴趣的可自行阅读代码。</p>
<p>详细见链接：<a href="https://github.com/baoyachi/rust-error-handle/blob/master/src/demo_nom_error_handle.rs">https://github.com/baoyachi/rust-error-handle/blob/master/src/demo_nom_error_handle.rs</a></p>
<h2><a class="header" href="#14-总结" id="14-总结">14. 总结</a></h2>
<p>好了，经过上面的长篇大论，不知道大家是否明白如何自定义处理Error呢了。大家现在带着之前的已有的问题或困惑，赶紧实战下<code>Rust</code>的错误处理吧，大家有疑问或者问题都可以留言我，希望这篇文章对你有帮助。</p>
<p>文中代码详见:<a href="https://github.com/baoyachi/rust-handle-error/tree/master/src">https://github.com/baoyachi/rust-handle-error/tree/master/src</a></p>
<p>原文地址:<a href="https://github.com/baoyachi/rust-error-handle">https://github.com/baoyachi/rust-error-handle</a></p>
<h1><a class="header" href="#rust-crates私有化部署指南private-alternative-registry" id="rust-crates私有化部署指南private-alternative-registry">Rust crates私有化部署指南(private alternative registry)</a></h1>
<p>在<code>Rust</code>中,一般使用外部依赖的库部署在<a href="https://crates.io/">https://crates.io/</a>。我们直接在<code>Cargo.toml</code>的<code>dependencies</code>配置即可，列如下配置：</p>
<pre><code class="language-toml">...
[dependencies]
rand = &quot;0.7.3&quot;
serde = &quot;1.0&quot;
serde_derive = &quot;1.0&quot;
serde_json = &quot;1.0&quot;
lazy_static = &quot;1.4.0&quot;
...
</code></pre>
<p>如果细心的同学会发现，如果<code>rand</code>库更新到<code>rand = &quot;0.7.4&quot;</code>时，我们执行<code>cargo update</code>，<code>Cargo.lock</code>会自动更新<code>rand</code>到最新的<code>0.7.4</code>版本。这主要是<code>Rust</code>采用了<a href="https://semver.org/">语义化版本</a>。</p>
<p>但是这样的依赖对于<code>Rust</code>提供的<code>crates.io</code>是没问题的，面对私有化的项目，即不能共享到公开的<code>crates</code>上，又想做到私有依赖，问题就暴露了。</p>
<h2><a class="header" href="#2cargo私有化git依赖" id="2cargo私有化git依赖">2.cargo私有化git依赖</a></h2>
<p>一般来说，企业的私有代码，都依赖于私有git仓库。翻过<code>cargo</code>的文档时，这里就提到了一个关于git私有化依赖的问题，详见链接：</p>
<ul>
<li><a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories</a></li>
</ul>
<p>这里的git私有化不外乎这几种依赖：<code>branch</code>依赖，<code>tag</code>依赖，<code>commit-id</code>依赖，列如下配置：</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot;, branch = &quot;master&quot; }
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot;, tag = &quot;0.2.2&quot; }
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot;, rev = &quot;e2112c4&quot; }
</code></pre>
<p>看到这里，我们就想到了才有私有化<code>git</code>方式依赖，我们也这样做了。接下来问题便发生了。</p>
<ul>
<li>2.1 在项目中，我们定义了一些公共依赖的结构：<code>hula_common</code>私有仓库。</li>
<li>2.2 <code>A</code>项目(lib)使用了<code>hula_common</code>的仓库，依赖<code>tag=&quot;0.1.5&quot;</code>如下</li>
</ul>
<pre><code class="language-toml">hula_common = { package = &quot;hula_common&quot;, git = &quot;ssh://git@git.baoyachi.com/hula/hula_common.git&quot; , tag = &quot;0.1.5&quot; }
</code></pre>
<ul>
<li>2.3. <code>B</code>项目(lib)也使用了<code>hula_common</code>的仓库，依赖<code>tag=&quot;0.1.4&quot;</code>如下</li>
</ul>
<pre><code class="language-toml">hula_common  = { package = &quot;hula_common&quot;, git   = &quot;ssh://git@git.baoyachi.com/hula/hula_common.git&quot; , tag = &quot;0.1.4&quot; }
</code></pre>
<ul>
<li>
<p>2.4 <code>A</code>lib和<code>B</code>lib都同时依赖了<code>hula_common</code>，两者区别就是引用的git的<code>tag</code>版本不同。</p>
</li>
<li>
<p>2.5 在主程序的<code>project</code>名称是<code>fuzz</code>中,<code>fuzz</code>同时依赖了<code>A</code>,<code>B</code>,<code>hula_common</code>等私有<code>lib</code>,大致如下：</p>
</li>
</ul>
<pre><code class="language-toml">...
[dependencies]
serde_derive = &quot;1.0.111&quot;
serde = &quot;1.0.111&quot;
serde_json = &quot;1.0.53&quot;
...

hula_common = { package = &quot;hula_common&quot;, git = &quot;ssh://git@git.baoyachi.com/hula/hula_common.git&quot; , tag = &quot;0.1.5&quot; }
B = { package = &quot;B&quot;, git = &quot;ssh://git@git.baoyachi.com/hula/B.git&quot; , tag = &quot;0.3.2&quot; }
A = { package = &quot;A&quot;, git = &quot;ssh://git@git.baoyachi.com/hula/A.git&quot; , tag = &quot;0.5.7&quot; }
...
</code></pre>
<ul>
<li>2.6 当我们编译<code>fuzz</code>时，居然编译报错?</li>
</ul>
<pre><code class="language-bash">error[E0308]: mismatched types
   --&gt; src/common/query.rs:196:23
    |
196 |         let items = self.query(pos, key)?;
    |                                ^^^^^ expected struct `hula_common::query::Container`, found struct `hula_common::query::Container`
    |
    = note: expected reference `&amp;hula_common::query::Container`
               found reference `&amp;hula_common::query::Container`
    = note: perhaps two different versions of crate `hula_common` are being used?
</code></pre>
<p>大致意思是：<code>hula_common</code>使用了不同版本(different versions),导致编译报错。这个很让人诡异：
对于上面提到的<code>rand</code>在<code>crates.io</code>的依赖，如果版本更新，会自动更新，反而因为<code>git</code>的<code>tag</code>差异，Rust认为导入的<code>crate</code>不一致，这个问题纠结了我很久。</p>
<p>一方面，想要让所有库依赖同一个<code>tag</code>，这个着实让人头疼。<code>hula_common</code>的定义由<code>0.1.4</code>-&gt;<code>0.1.5</code>,可能只是针对<code>B</code>项目增加的局部字段，而不会影响<code>A</code>项目的编译。按理说，若<code>Rust</code>遵循<a href="https://semver.org/">https://semver.org</a>语义化版本的依赖，应该是可以正常编译过的，但现实是failed。</p>
<p>如果熟悉<code>go mod</code>的依赖，就会发现，上面这种依赖方式，在<code>go mod</code>编译时，是完全ok的。同样的问题，对于<code>Rust</code>来说，为何编译失败？因此，带着问题，寻求官方的回复，有人便给了反馈,原话如下：</p>
<pre><code class="language-bash">Cargo has no way of knowing that two different tags point to compatible projects. If you want a shared dependency on a git project it has to be the same commit to be compatible. Cargo will happily build both tags into the same project, but it will not treat types from one as the same as types from the other.

...
git tags are arbitrary strings, we have no way to know if &quot;master&quot; and &quot;dev&quot; are sember compatible. crates.io versions are semver versions, so we can determine that &quot;^0.1.4&quot; can resolve to 0.1.5. Note that if you have &quot;=0.1.4&quot; as a requirement on crates.io you would also get an error.

Your company may want to create a private alternative registry.
</code></pre>
<p>大致意思是：Cargo无法知道两个不同的tag指向兼容的项目。如果要共享对git项目的依赖，则必须具有相同的commit才能兼容。本身git的<code>tag</code>可以是任意字符串，<code>Cargo</code>无法知道<code>master</code>和<code>dev</code>是否与<code>semver versions</code>的版本兼容。</p>
<p>如果真的要使用<code>semver versions</code>让<code>Cargo</code>认识，需要创建类似<code>crates.io</code>的私有<code>private alternative registry</code>。</p>
<h2><a class="header" href="#3-alternative-registry" id="3-alternative-registry">3 alternative registry</a></h2>
<p>在<code>Rust 1.34.0</code>的版本中，支持了<code>Alternative cargo registries</code>。什么意思？通常我们不仅仅依赖<code>crates.io</code>上的代码，在企业或其他组织中，存在大量私有仓库代码（gitlab）,使得我们在对于<code>Cargo</code>依赖时，既需要依赖<code>crates.io</code>，又要有其他的<code>registry</code>依赖，<code>1.34.0</code>的版本开始支持了该特性。大致配置如下：</p>
<ul>
<li>
<p>3.1 创建在git上的<code>crate index</code>的存储仓库
假设我们在gitlab上创建了一个关于私有的<code>crates</code>的存储仓库：<code>https://git.baoyachi.com/hula/crates-index.git</code>。</p>
</li>
<li>
<p>3.2 找到<code>.cargo</code>的根目录，创建<code>config.toml</code>文件（./cargo/config.toml）,在<code>config.toml</code>配置自己的<code>registry</code>,假设我们命名:<code>git-baoyachi</code>, 并做如下配置：</p>
</li>
</ul>
<pre><code class="language-toml">[registries]
git-baoyachi = { index = &quot;https://git.baoyachi.com/hula/crates-index&quot; }
</code></pre>
<p>或是这样：</p>
<pre><code class="language-toml">[registries.git-baoyachi]
index = &quot;https://git.baoyachi.com/hula/crates-index&quot;
</code></pre>
<p><strong>上面两者是等价的，二选一即可。</strong></p>
<p>注意：假设私有仓库是<code>gitlab</code>,这里的<code>index</code>的链接即为gitlab的链接，即为：<code>https://git.baoyachi.com/hula/crates-index.git</code>。这里我们使用的是<code>http</code>或<code>https</code>的方式，如果是ssh的话，列配置如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[registries.git-baoyachi]
index = &quot;ssh://git@git.baoyachi.com/hula/crates-index.git&quot;
<span class="boring">}
</span></code></pre></pre>
<p>或是这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[registries]
git-baoyachi = {index = &quot;ssh://git@git.baoyachi.com/hula/crates-index.git&quot;}
<span class="boring">}
</span></code></pre></pre>
<p>请注意:<strong>从gitlab的克隆按钮复制/粘贴时，SSH网址有两个主要区别：必须在前面添加ssh://，并将gi.xxx.com之后的<code>:</code>更改为<code>/</code></strong></p>
<ul>
<li>3.3 配置crates备用注册表的服务
如果读了文档的，细心的同学会发现，文档中只是介绍了怎么配置，因为并没有告诉怎么搭建私有的<code>alternative registry</code>。好在开源社区提供了私有化的crates的注册服务:<a href="https://github.com/Hirevo/alexandrie">https://github.com/Hirevo/alexandrie</a></li>
</ul>
<p>我们跟着文档手册手动搭一个试试：<a href="https://hirevo.github.io/alexandrie/installation-script.html">https://hirevo.github.io/alexandrie/installation-script.html</a></p>
<ul>
<li>3.3.1 创建安装配置脚本:<code>alexandrie.sh</code></li>
</ul>
<pre><code class="language-bash">#!/bin/bash

# function to run when an error is encountered
function setup_error {
    echo &quot;-------- An error occurred during configuration --------&quot;
    exit 1
}

# exit on error
trap 'setup_error' ERR

# directory to clone Alexandrie into:
ALEXANDRIE_DIR=&quot;$2&quot;;

# URL to the crate index repository.
CRATE_INDEX_GIT_URL=&quot;$1&quot;;


while ! git ls-remote -h $CRATE_INDEX_GIT_URL; do
    read -p 'CRATE_INDEX_GIT_URL: ' CRATE_INDEX_GIT_URL;
done

if ! cargo -V; then
    echo;
    echo &quot;In order to build an instance of Alexandrie, you need to have Rust installed on your system&quot;;
    echo &quot;You can learn how to install Rust on your system on the official Rust website:&quot;;
    echo &quot;https://www.rust-lang.org/tools/install&quot;;
    echo;
    ! :;    # trigger error trap
fi

if [ -d &quot;$ALEXANDRIE_DIR&quot; ]; then
    echo
    echo &quot;'$ALEXANDRIE_DIR' (ALEXANDRIE_DIR) is an existing directory, pulling latest changes ...&quot;;
    cd &quot;$ALEXANDRIE_DIR&quot;;
    git pull;
    echo &quot;Changes have been pulled successfully !&quot;;
    echo;
else
    echo;
    echo &quot;Cloning Alexandrie in '$ALEXANDRIE_DIR' ...&quot;;
    git clone https://github.com/Hirevo/alexandrie.git &quot;$ALEXANDRIE_DIR&quot;;
    cd &quot;$ALEXANDRIE_DIR&quot;;
    echo &quot;Successfully cloned Alexandrie !&quot;;
    echo;
fi

echo &quot;Building Alexandrie (using the default features)...&quot;;
echo &quot;(keep in mind that the default features may not fit your use-case, be sure to review them before deplying it to production)&quot;;
cargo build -p alexandrie;
echo &quot;Alexandrie has been built successfully !&quot;;

# create the directory serving as the storage of crate archives.
mkdir -p crate-storage;

# setup the crate index.
if [ -d crate-index ]; then
    echo;
    echo &quot;'${ALEXANDRIE_DIR}/crate-index' is an existing directory, pulling latest changes ...&quot;;
    cd crate-index;
    git pull;
    echo &quot;Changes have been pulled successfully !&quot;;
    echo;
else
    echo;
    echo &quot;Cloning crate index in '${ALEXANDRIE_DIR}/crate-index' ...&quot;;
    git clone &quot;$CRATE_INDEX_GIT_URL&quot; crate-index;
    cd crate-index;
    echo &quot;Successfully cloned the crate index !&quot;;
    echo;
fi

# configure the crate index
if [ ! -f config.json ]; then
    echo &quot;The crate index does not have a 'config.json' file.&quot;;
    echo &quot;Creating an initial one (please also review it before deploying the registry in production) ...&quot;
    cat &gt; config.json &lt;&lt; EOF;
{
    &quot;dl&quot;: &quot;http://$(hostname):3000/api/v1/crates/{crate}/{version}/download&quot;,
    &quot;api&quot;: &quot;http://$(hostname):3000&quot;,
    &quot;allowed-registries&quot;: [&quot;https://github.com/rust-lang/crates.io-index&quot;]
}
EOF
    git add config.json;
    git commit -m 'Added `config.json`';
    git push -u origin master;
    echo &quot;Initial 'config.json' file has been created and pushed to the crate index !&quot;;
    echo;
fi

echo &quot;Alexandrie should be good to go for an initial run.&quot;;
echo &quot;You can start the Alexandrie instance by:&quot;;
echo &quot;  - navigating to '${ALEXANDRIE_DIR}'&quot;;
echo &quot;  - tweaking the 'alexandrie.toml' file&quot;;
echo &quot;  - run `./target/debug/alexandrie`&quot;;
echo;

</code></pre>
<p>注意：该脚本需要两个参数：</p>
<ul>
<li>
<p><code>ALEXANDRIE_DIR</code>: 本地的路径,列如：/home/baoyachi/alexandrie</p>
</li>
<li>
<p><code>CRATE_INDEX_GIT_URL</code>:就是我们在3.1创建的<code>crats index</code>的git地址，如：<code>ssh://git@git.baoyachi.com/hula/crates-index.git</code></p>
</li>
<li>
<p>3.3.2 执行脚本</p>
</li>
</ul>
<pre><code class="language-bash">sh alexandrie.sh ssh://git@git.baoyachi.com/hula/crates-index.git /home/baoyachi/alexandrie
</code></pre>
<p>解释下该脚本做的工作：clone <code>CRATE_INDEX_GIT_URL</code>仓库，创建<code>config.json</code>,配置如下：</p>
<pre><code class="language-json">{
    &quot;dl&quot;: &quot;http://{{host:port}}/api/v1/crates/{crate}/{version}/download&quot;,
    &quot;api&quot;: &quot;http://{{host:port}}&quot;,
    &quot;allowed-registries&quot;: [&quot;https://github.com/rust-lang/crates.io-index&quot;]
}
</code></pre>
<p>这里的<code>host</code>,<code>port</code>最终换成线上部署的服务。</p>
<ul>
<li>3.3.3 启动服务</li>
</ul>
<pre><code class="language-bash">cd /home/baoyachi/alexandrie
./target/debug/alexandrie alexandrie.toml
</code></pre>
<p>服务启动完成，大致输出如下：</p>
<pre><code class="language-bash">➜  alexandrie git:(master) ./target/debug/alexandrie alexandrie.toml
Jul 26 22:23:36.382 INFO running database migrations, version: 0.1.0
Jul 26 22:23:36.383 INFO setting up request logger middleware, version: 0.1.0
Jul 26 22:23:36.383 INFO setting up cookie middleware, version: 0.1.0
Jul 26 22:23:36.384 INFO setting up authentication middleware, version: 0.1.0
Jul 26 22:23:36.384 INFO mounting '/', version: 0.1.0
Jul 26 22:23:36.384 INFO mounting '/me', version: 0.1.0
Jul 26 22:23:36.384 INFO mounting '/search', version: 0.1.0
Jul 26 22:23:36.385 INFO mounting '/most-downloaded', version: 0.1.0
Jul 26 22:23:36.385 INFO mounting '/last-updated', version: 0.1.0
Jul 26 22:23:36.385 INFO mounting '/crates/:crate', version: 0.1.0
Jul 26 22:23:36.386 INFO mounting '/account/login', version: 0.1.0
Jul 26 22:23:36.386 INFO mounting '/account/logout', version: 0.1.0
Jul 26 22:23:36.386 INFO mounting '/account/register', version: 0.1.0
...
...
Jul 26 22:23:36.391 INFO mounting '/api/v1/crates/:name', version: 0.1.0
Jul 26 22:23:36.391 INFO mounting '/api/v1/crates/:name/owners', version: 0.1.0
Jul 26 22:23:36.392 INFO mounting '/api/v1/crates/:name/:version/yank', version: 0.1.0
Jul 26 22:23:36.392 INFO mounting '/api/v1/crates/:name/:version/unyank', version: 0.1.0
Jul 26 22:23:36.392 INFO mounting '/api/v1/crates/:name/:version/download', version: 0.1.0
Jul 26 22:23:36.392 INFO listening on 127.0.0.1:3000, version: 0.1.0
Jul 26 22:23:36.392 INFO Server listening on http://127.0.0.1:3000, version: 0.1.0
</code></pre>
<ul>
<li>3.4 执行cargo login
在执行<code>cargo login --registry=my-registry</code>,这里的<code>my-registry</code>即为3.2配置的index名称，假设为：<code>git-baoyachi</code>,则执行</li>
</ul>
<pre><code class="language-bash">➜ cargo login --registry=git-baoyachi
please visit http://localhost:3000/me and paste the API Token below
2506b7bd94dfc708b755d5399
       Login token for `git-baoyachi` saved
</code></pre>
<p>提示我们需要输入token,我们在3.3.3启动的本地服务，访问http://localhost:3000/me，系统提示我们注册，生成token，大致如下：
<img src="Rust/./alexandrie_get_token.png" alt="token" /></p>
<ul>
<li>3.5 创建，发布私有<code>crates</code>库
假设我们创建了库，<code>cargo new hula-common --lib</code>,我们将该库发布到指定的私有git仓库中，如3.1所述，执行如下命令,这里的<code>my-registry</code>即为3.2配置的index名称，假设为：<code>git-baoyachi</code>,则执行</li>
</ul>
<pre><code class="language-bash">cargo publish --registry=git-baoyachi
</code></pre>
<p>如果login成功的话，执行结果大致如下：</p>
<pre><code class="language-bash">➜  cargo publish --registry=git-baoyachi 
    Updating `ssh://git@git.baoyachi.com/hula/crates-index.git` index
warning: manifest has no description, license, license-file, documentation, homepage or repository.
See https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.
   Packaging hula-common v1.0.2 (/home/baoyachi/git_project/crates-index/hula-common)
   Verifying hula-common v1.0.2 (/home/baoyachi/git_project/crates-index/hula-common)
   Compiling hula-common v1.0.2 (/home/baoyachi/git_project/crates-index/hula-common/target/package/h2-1.0.2)
    Finished dev [unoptimized + debuginfo] target(s) in 1.18s
   Uploading hula-common v1.0.2 (/home/baoyachi/git_project/crates-index/hula-common)
➜     
</code></pre>
<p>注意，<code>alexandrie</code>会检查<code>Cargo.toml</code>的版本<code>version = &quot;1.0.3&quot;</code>，如果同一版本publish多次，会报如下错误：</p>
<pre><code class="language-bash">error: failed to get a 200 OK response, got 500
headers:
	HTTP/1.1 100 Continue

	HTTP/1.1 500 Internal Server Error

	content-length: 0

	date: Sun, 26 Jul 2020 10:42:46 GMT

body:
</code></pre>
<p>我们需要检查当前库的版本号是否重复即可。如果按上步骤执行ok的话，<code>alexandrie</code>会自动push我们仓库的私有<code>crates</code>的git仓库，更新当前publish库的信息。</p>
<h2><a class="header" href="#4-使用私有crates依赖" id="4-使用私有crates依赖">4. 使用私有crates依赖</a></h2>
<p>我们在第一章节也详细描述了，如果使用git的<code>branch</code>或<code>tag</code>依赖时，会出现当前<code>perhaps two different versions of crate</code>的问题，我们花了大量篇幅讲解如果使用创建和发布私库，就是为了解决git依赖的问题。那么，答案来了，我们只需要修改<code>Cargo.toml</code>的<code>dependencies</code>依赖即可，我们还是以第一章列子举例配置：</p>
<pre><code class="language-toml">...
[dependencies]
serde_derive = &quot;1.0.111&quot;
serde = &quot;1.0.111&quot;
serde_json = &quot;1.0.53&quot;
...

hula_common = { version=&quot;0.1.4&quot;, registry = &quot;git-baoyachi&quot; }
B = { package = &quot;B&quot;, version=&quot;0.3.2&quot;, registry = &quot;git-baoyachi&quot; }
A = { package = &quot;A&quot;, version=&quot;0.5.7&quot;, registry = &quot;git-baoyachi&quot; }
...
</code></pre>
<p>我们只需要在依赖后面，指定自定义的<code>registry</code>配置即可。这样，即使<code>hula_common</code>升级到<code>version=&quot;0.1.5&quot;</code>,我们执行<code>cargo update</code>也可以让正常编译。</p>
<h2><a class="header" href="#5总结" id="5总结">5.总结</a></h2>
<p>我们想建立私有的<code>crates</code>的配置，大致需要如下几步：</p>
<ul>
<li>创建存储<code>crates-index</code>的私有仓库</li>
<li>部署 <a href="https://github.com/Hirevo/alexandrie">alexandrie</a>的私有服务，绑定域名</li>
<li>建立认证，获取<code>cargo login</code>的<code>token</code></li>
<li>对应<code>lib</code>执行<code>cargo publish</code></li>
<li>使用依赖，配置指定<code>registry</code></li>
</ul>
<h2><a class="header" href="#写在最后" id="写在最后">写在最后</a></h2>
<p>关于这部分的问题，Rust的相关资料在中文社区，网上的查到还是较少，一方面是语言普及度的原因，另一方面是社区分享的少。但这并不妨碍我们解决问题。对于先吃螃蟹的，总会磕磕绊绊，在这解决问题的过程中，对于问题的刨根，和开源社区交流，沟通以及协作上的思维方式还是有不少收获。</p>
<h2><a class="header" href="#参考链接" id="参考链接">参考链接</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/cargo/issues/8536">https://github.com/rust-lang/cargo/issues/8536</a></li>
<li><a href="https://doc.rust-lang.org/cargo/reference/registries.html#using-an-alternate-registry">https://doc.rust-lang.org/cargo/reference/registries.html#using-an-alternate-registry</a></li>
<li><a href="https://github.com/Hirevo/alexandrie/issues/75">https://github.com/Hirevo/alexandrie/issues/75</a></li>
<li><a href="https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html">https://blog.rust-lang.org/2019/04/11/Rust-1.34.0.html</a></li>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/2141-alternative-registries.md">https://github.com/rust-lang/rfcs/blob/master/text/2141-alternative-registries.md</a></li>
</ul>
<h1><a class="header" href="#rust代码优化-闭包惰性求值" id="rust代码优化-闭包惰性求值">Rust代码优化-闭包惰性求值</a></h1>
<p><img src="https://github.com/baoyachi/baoyachi.github.io/blob/master/png/rust/code_practice.jpg?raw=true" alt="code_practice" /></p>
<h2><a class="header" href="#背景" id="背景">背景</a></h2>
<p>写代码时，经常会遇到从<code>Option</code>或<code>Result</code>中取值得问题，为了避免使用<code>unwrap()</code>,使用了<code>if let Some(xxx)</code>或<code>if let Ok(xxx)</code>
的代码表达。之前的文章也介绍了这种写法，惯用法也自以为习以为常。</p>
<ul>
<li>1.最近一次代码在发PR时，下面这段代码作者建议，又有了写收获：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Message(usize);

fn get_msg(msg: &amp;Option&lt;Message&gt;) -&gt; String {
    let mut rep_msg = &quot;Ok&quot;.to_string();
    if let Some(msg) = msg {
        rep_msg = format!(&quot;{}&quot;, msg.0)
    }
    rep_msg
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>2.为了避免<code>resp_msg</code>使用<code>mut</code>，建议改使用下面这种方式：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_msg(msg: &amp;Option&lt;Message&gt;) -&gt; String {
    let rep_msg = if let Some(msg) = msg {
        format!(&quot;{}&quot;, msg.0)
    } else {
        &quot;Ok&quot;.to_string()
    };
    rep_msg
}
<span class="boring">}
</span></code></pre></pre>
<p>通过赋值方式传递<code>rep_msg</code>,避免了<code>rep_msg</code>的可变性。</p>
<ul>
<li>3.本身上面代码看起来还是有点绕口，为了表达直观，通过代码块<code>{}</code>，可表达为下面方式：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_msg(msg: &amp;Option&lt;Message&gt;) -&gt; String {
    let rep_msg = {
        if let Some(msg) = msg {
            format!(&quot;{}&quot;, msg.0)
        } else {
            &quot;Ok&quot;.to_string()
        }
    };
    rep_msg
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>4.但是上面代码看起来还是有点啰嗦，我们继续优化，可以采用<code>Option</code>的组合子方法，链式表达，修改如下</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_msg(msg: &amp;Option&lt;Message&gt;) -&gt; String {
    msg.as_ref().map(|msg| format!(&quot;{}&quot;, msg.0)).unwrap_or(&quot;Ok&quot;.to_string())
}
<span class="boring">}
</span></code></pre></pre>
<p>是不是使用combinator的模式，代码更简单、直观了。但是，这里还是有点缺陷，我们继续往下看：</p>
<ul>
<li>5.如果使用<code>cargo clippy</code>的使用，<code>clippy</code>会经常提示我们修改这段逻辑：</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>msg.unwrap_or(&quot;Ok&quot;.to_string())
 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or_else(|| &quot;OK&quot;.to_string())`
                                          |
<span class="boring">}
</span></code></pre></pre>
<p>为什么呢？对于<code>unwrap_or</code>,即使不使用其值，参数<code>&quot;Ok&quot;.to_string()</code>也将进行求值。对于<code>unwrap_or_else</code>，参数接收一个闭包，
当触发<code>unwrap_or_else</code>调用时，通过传递函数(闭包)进行惰性求值(lazy evaluation)计算，提升程序性能,那我们改造下</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_msg(msg: &amp;Option&lt;Message&gt;) -&gt; String {
    msg.as_ref().map(|msg| format!(&quot;{}&quot;, msg.0)).unwrap_or_else(||&quot;Ok&quot;.to_string())
}
<span class="boring">}
</span></code></pre></pre>
<p>从第一个函数看到现在，有么有收获呢？欢迎大家在评论区留言，一起交流。</p>
<h2><a class="header" href="#最后" id="最后">最后</a></h2>
<p>推荐大家在Rust项目中，将 <a href="https://github.com/rust-lang/rust-clippy">clippy</a> 这个插件使用起来，优化程序的结构。让优秀成为一种习惯。</p>
<h2><a class="header" href="#参考链接-1" id="参考链接-1">参考链接</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rust/pull/55014">https://github.com/rust-lang/rust/pull/55014</a></li>
<li><a href="https://stackoverflow.com/questions/56726571/why-choosing-unwrap-or-else-over-unwrap-or">https://stackoverflow.com/questions/56726571/why-choosing-unwrap-or-else-over-unwrap-or</a></li>
<li><a href="https://stackoverflow.com/questions/45547293/why-should-i-prefer-optionok-or-else-instead-of-optionok-or">https://stackoverflow.com/questions/45547293/why-should-i-prefer-optionok-or-else-instead-of-optionok-or</a></li>
</ul>
<h1><a class="header" href="#golang" id="golang">golang</a></h1>
<p>golang 杂谈</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
